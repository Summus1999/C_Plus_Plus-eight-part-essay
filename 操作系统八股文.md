# 操作系统八股文

### 死锁的发生条件，如何解决

死锁是指一组进程/线程互相等待对方持有的资源,导致它们都无法继续执行的情况。死锁的产生有四个条件，互斥，不可剥夺，请求和保持以及循环等待。要解决死锁问题只要破解其中一个条件即可。
进程调度算法可以通过以下方式来**预防和解决死锁**:

- 银行家算法: 预先分配资源,确保不会进入死锁状态。
- 资源分配图算法: 检测资源分配图中是否存在环路,从而判断是否会发生死锁。
- 死锁检测与解除: 定期检测系统中是否存在死锁,如果存在则通过抢占资源或者终止进程来解除死锁。

### 进程和线程的区别？

进程是**资源分配的基本单位**，线程是**CPU调度的基本单位**。
从并发性角度看，切换进程是要涉及到虚拟内存空间的切换的，线程切换不涉及，多线程共享同一个虚拟内存空间，进程切换还会涉及上下文（即寄存器组）的切换。进程在创建时会申请内存，每个进程内都有一个页表存在于内存中。切换进程导致页表中的TLB快表失效，寄存器内的内容都需要重新写入，被终止运行的进程的中间数据会存在进程的私有堆栈中，线程的切换就不会使TLB失效，速度就会快很多。多个线程之间共享的部分有全局变量和静态变量，堆，部分全局数据结构和共享库以及动态链接库。

### 进程的调度策略

- 先到先服务：非抢占式调度，实现简单但可能导致"护航效应"
- 最短作业优先：最小化平均等待时间，长进程可能饥饿
- 轮转调度：性能开销大或退化为先来先服务
- 多级反馈队列：I/O密集型进程：升至高优先级队列（快速响应）。CPU密集型进程：降至低优先级队列（避免抢占开销）。进程老化：低优先级进程随等待时间自动升级
  
### 虚拟内存是如何工作的？

虚拟内存是现代操作系统的核心内存管理技术，通过硬件（如MMU）与软件（操作系统）的协同，为进程提供连续的虚拟地址空间，并动态映射到物理内存或磁盘空间。

- 虚拟地址空间机制：每个进程拥有独立的虚拟地址空间（如32位系统为4GB），进程仅使用虚拟地址（VA）访问内存。虚拟内存包含RAM和磁盘交换空间，拓展可用内存，如手机使用虚拟内存机制提高可用内存。
- 分页机制：虚拟地址空间被划分为固定大小的页，操作系统为每个进程维护的映射表，存储虚拟页号（VPN）到物理页框号（PFN）的映射关系。

虚拟内存的**优点**：防止进程越界访问，提升安全性。允许程序使用超过物理内存的空间。

常用的虚拟内存的性能优化技术
- 加速地址转换：TLB（快表）​：TLB是MMU内部的硬件缓存，存储近期使用的PTE，避免频繁访问主存页表。
- 多级页表：仅加载活跃部分的子页表，减少内存占用。

### 介绍一下用户态和内核态？

用户态（User Mode）和内核态（Kernel Mode）是操作系统中的两种核心运行模式，用于隔离应用程序与系统核心功能，保障系统安全性和稳定性。通过系统调用、中断和异常实现动态切换，平衡效率与安全。

- 用户态：应用程序独占，通过用户级页表映射物理内存，禁止执行特权指令，尝试执行会触发异常并切换到内核态

- 核心态：所有进程共享，通过内核级页表映射操作系统代码和数据，用户程序无法修改，可执行所有指令，可以访问内核资源。

### 上下文切换时需要保存用户态的哪些内容？

操作系统保存的内容如下：( 所有用户态上下文保存在**进程控制块**)上下文切换的本质是保存与恢复进程的执行现场。

- 寄存器状态：如程序计数器，堆栈指针，通用寄存器和状态寄存器的状态，需要记录
- 栈信息：保存了**函数调用帧**，切换时需要完整保存。
- 内存管理信息：上下文切换时需要记录内存管理信息，如页表基址和段寄存器。
- 其他用户态状态：如浮点寄存器或者线程的局部存储指针。

触发场景：主动切换如系统调用，被动切换如时间片耗尽。如果是内核态切换还会记录中断状态、内核栈等系统级信息。
