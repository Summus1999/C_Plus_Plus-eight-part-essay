# 操作系统八股文

### 死锁的发生条件，如何解决

死锁是指一组进程/线程互相等待对方持有的资源,导致它们都无法继续执行的情况。死锁的产生有四个条件，互斥，不可剥夺，请求和保持以及循环等待。要解决死锁问题只要破解其中一个条件即可。
进程调度算法可以通过以下方式来**预防和解决死锁**:

- 银行家算法: 预先分配资源,确保不会进入死锁状态。
- 资源分配图算法: 检测资源分配图中是否存在环路,从而判断是否会发生死锁。
- 死锁检测与解除: 定期检测系统中是否存在死锁,如果存在则通过抢占资源或者终止进程来解除死锁。

### 进程和线程的区别？

进程是**资源分配的基本单位**，线程是**CPU调度的基本单位**。
从并发性角度看，切换进程是要涉及到虚拟内存空间的切换的，线程切换不涉及，多线程共享同一个虚拟内存空间，进程切换还会涉及上下文（即寄存器组）的切换。进程在创建时会申请内存，每个进程内都有一个页表存在于内存中。切换进程导致页表中的TLB快表失效，寄存器内的内容都需要重新写入，被终止运行的进程的中间数据会存在进程的私有堆栈中，线程的切换就不会使TLB失效，速度就会快很多。多个线程之间共享的部分有全局变量和静态变量，堆，部分全局数据结构和共享库以及动态链接库。

### 进程的调度策略

- 先到先服务：非抢占式调度，实现简单但可能导致"护航效应"
- 最短作业优先：最小化平均等待时间，长进程可能饥饿
- 轮转调度：性能开销大或退化为先来先服务
- 多级反馈队列：I/O密集型进程：升至高优先级队列（快速响应）。CPU密集型进程：降至低优先级队列（避免抢占开销）。进程老化：低优先级进程随等待时间自动升级
