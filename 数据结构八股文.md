# 数据结构八股文

## vector的特点和扩容机制

vector的实现底层是一个一维数组。vector通过一个连续的一维数组存放元素，如果这个数组的容量已满，再往这个数组中插入数据的时候，需要申请一块更大的内存，然后把原来数组的数据复制到新数组中来，再释放原来数组的内存。
vector的扩容策略有三种：

- 将数组扩充n倍：如g++编译器是扩充到原来的2倍
- 将数组扩充50%：如visual studio中的vector是1.5倍扩容
- 按需要扩容
如果要一次性插入大量数据可以使用reserve()函数先进行提前扩容，减少扩容的次数，提高性能。

## 双端队列的特点和实现

双端队列是一种具有队列和栈特性的线性数据结构，允许在两端进行插入和删除操作。

- 特点：可以在前端（front）和后端（back）进行插入和删除操作。支持 O(1) 时间复杂度的随机访问。可以根据需要自动扩展容量。

## map和unordered_map的区别,unordered_map是否线程安全？

- map是基于**红黑树**实现的有序关联容器，它会根据键的大小自动进行排序，插入和查找操作的平均时间复杂度为 O(log n)，适合需要元素有序存储，并且需要频繁进行插入和删除操作的场景。map的空间占用率高。map不是线程安全的，可以使用shared_mutex保护容器的访问。
- unordered_map是基于**哈希表**实现的无序关联容器，它使用哈希函数将键映射到存储桶中，插入和查找操作的平均时间复杂度为 O(1)，适合需要快速查找元素，并且不需要元素有序存储的场景。unordered_map查找速度快，建立哈希表时间长，占用内存高。总的来说是以空间换时间的一种容器。unordered_map是**非线程安全的**，可以使用shared_mutex保护容器的访问，也可以用一些第三方的线程安全库如boost thread。

## 红黑树的特点

红黑树（Red-Black Tree）是一种自平衡的二叉查找树（BST），它在每个节点上增加一个存储位表示节点的颜色（红色或黑色），通过颜色的约束规则确保树保持近似平衡，保证在最坏情况下基本操作（插入、删除、查找）的时间复杂度为O(log n)。

红黑树的五大特性（规则）：

- 每个节点是红色或黑色。
- 根节点是黑色。
- 所有叶子节点（NIL节点，空节点）都是黑色。
- 在红黑树中，叶子节点不存储数据，通常用NIL节点表示，且为黑色。
- 红色节点的两个子节点都是黑色（即不能有两个连续的红色节点）。
从任一节点到其每个叶子（NIL节点）的所有路径都包含相同数目的黑色节点（称为黑高相同）。

## AVL树和红黑树的区别

- AVL树严格平衡：任意节点的左右子树高度差不超过1。AVL树需要频繁旋转。每个节点需要存储平衡因子（通常4字节。
- 红黑树：满足五个约束条件，但允许最长路径是最短路径的2倍。旋转次数有上限（插入最多2次，删除最多3次）。每个节点只需1位存储颜色信息（通常用1字节实现）

## 排序算法有哪些？

- 冒泡排序：重复遍历列表，比较相邻元素，如果顺序错误就交换，直到没有需要交换的元素。简单、效率低
- 选择排序：每次从未排序部分选择最小（或最大）元素，放到已排序部分的末尾。不稳定
- 插入排序：将每个元素插入到已排序部分的正确位置。性能差
- 希尔排序：插入排序的改进，通过将列表分成多个子序列（按增量）进行插入排序，逐渐减小增量直至1。不稳定
- 归并排序：分治法。将列表分成两半，分别排序，然后合并两个有序列表。稳定效率高但内存占用多
- 快速排序：选择一个基准元素，将列表分为小于基准和大于基准的两部分，递归排序。**平均性能非常好**
- 堆排序：利用堆这种数据结构，将列表构建成最大堆（或最小堆），然后不断取出堆顶元素（最大或最小）并调整堆。不稳定
