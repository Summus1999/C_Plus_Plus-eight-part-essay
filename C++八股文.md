# C++八股文

### C++面向对象的三大特性？

**封装**：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。
**继承**：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修改为private级别，也可以使用using去修改权限)，还可以做多继承和接口继承。
**多态**：一个接口多种形态，通过实现接口重用增加可扩展性。分为静态多态和动态多态。

- 静态多态：函数重载
- 动态多态：通过虚函数重写

### C++多态的实现

C++的多态分为静态多态和动态多态。

**静态多态**的实现原理是**函数重载和模板函数**(编译器确定)。

- 函数重载指的是在同一个作用域内，可以定义多个函数，它们具有相同的名称但参数列表不同的情况。在调用这些函数时，编译器会根据函数调用时提供的参数类型和数量来确定调用哪个函数。模板函数是指在定义函数时使用了类型参数，让函数适用于多种不同的类型。编译器在编译时根据参数类型生成具体的函数实现。模板函数的实现是通过编译时的模板实例化来实现的。

**动态多态**指的是在**运行时**根据对象的实际类型确定要调用的函数。动态多态实现的方法是**虚函数重写和抽象类**。虚函数是指在基类中定义的函数可以被派生类重写的函数。通过将函数声明为虚函数，我们可以在运行时根据对象的实际类型来确定要调用的函数实现。在C++中，只要将函数声明为虚函数即可实现动态多态。抽象类是指包含至少一个纯虚函数的类，这个类不能被实例化，只能用作基类来派生出其他类。在C++中，可以通过将函数声明为纯虚函数来实现抽象类。其原理就是早绑定和晚绑定。早绑定即编译时确定调用函数的地址，晚绑定即类使用virtual函数时生成虚表存放虚函数的地址，类对象构造时进行初始化。

### C++指针和引用的区别？

在 C++中，引用本身并不占用额外的内存空间。当你传递一个变量作为引用参数给函数时，函数内部会使用该引用来直接操作原始变量，而不是创建原始变量的副本。因此，使用引用可以避免不必要的数据复制，提高程序的效率。引用的内部实现通常是通过指针来完成的，因此在函数调用时，引用本身并不会在栈上分配额外的内存空间，只是会使用一个指针来指向原始变量的内存地址。总结起来，引用不占用函数栈内存，但会占用一个指针的大小。
指针与引用的区别：

- 指针本身是一个对象，允许进行赋值和拷贝等操作。
- 指针的生命周期内可以指向几个不同的对象，引用不可以。
- 指针不需要在定义时赋初值。
需要注意的是，引用在底层实现上通常被编译器实现为指针，但是在使用时更类似于被引用的变量本身。引用在编译时会被转换为指针。引用在被使用的使用会占用4个字节大小的内存空间，也就是一个指针的大小

### C++的构造函数能否定义为虚函数？

不能。

- 虚函数通过虚表实现多态，每个类内存有一个虚表，表内存放虚指针。这个虚指针是构造对象时被初始化的。

- **虚函数的工作机制**：虚函数通过虚函数表（vtable）来实现多态。每个包含虚函数的类都有一个虚函数表，其中存放了指向该类虚函数的指针。每个对象在创建时，会有一个指向其虚函数表的指针（vptr）。这个vptr是在对象构造期间被初始化的。从构造函数的**调用时序**看，在构造一个派生类对象时，首先调用基类的构造函数，然后依次调用派生类的构造函数。在基类构造函数执行期间，对象的类型是基类类型，而不是派生类类型。C++语言标准明确规定，构造函数不能是虚函数。如果你尝试在构造函数声明前加上virtual关键字，编译器会报错。

### 智能指针有没有了解？shared_ptr和unique_ptr讲一下

智能指针的实现是利用了RAII的技术对普通指针进行封装，使得智能指针本质上是一个对象，却表现出一个指针的行为。智能指针的**作用**是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存，解决多次释放同一指针造成崩溃的问题。智能指针还可以把值语义转换成引用语义。

智能指针的内存问题：智能指针位于栈区域，它管理的对象是位于堆区域。堆区域是程序运行时内存动态分配的地方，智能指针指向堆上的对象，当不再需要这个对象时会自动释放内存。

- shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁，因为shared_ptr的指向对象部分并不是线程安全的。
- unique_ptr独占其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。与原始指针相比，unique_ptr由于其RAII的特性，使得在出现异常的情况下，动态资源仍然能得到释放。
- weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。C++11中被废弃。

### 对锁有没有了解，介绍一下？

- mutex:最基本的互斥锁，不可重入
- recursive_mutex：可重入互斥锁，允许同一线程多次加锁
- timed_mutex：带超时功能的互斥锁，尝试获取锁一段时间，超时则返回。
- recursive_timed_mutex：可重入且支持超时
- shared_mutex：读写锁，支持两种访问模式，适用于读多写少的场景。
- shared_timed_mutex：shared_mutex基础上增加了超时功能

### C++移动语义move的作用？

move作用主要是可以将一个左值转换成右值引用，可以调用C++11右值引用的拷贝构造函数，在对象拷贝的时候，在运行时，move函数可以减少资源创建和释放。

```c++
#include <utility>
int main() {
    int x = 42;
    int y = std::move(x); // 将 x 转换为右值引用，不会进行拷贝操作
    return 0;
}
```

### move和forward的区别？

- move:将对象无条件转换为右值引用，启用移动语义.无论接受左值还是右值，都返回右值引用。实质是静态类型转换：static_cast<T&&>(t)

```c++
std::string s1 = "Hello";
std::string s2 = std::move(s1);  // 移动构造，s1 变为空
```

- forward:在模板中完美转发参数，保持原始值类别（左值/右值）。仅在模板中使用（通常是通用引用 T&&）。根据模板参数T的类型决定转发为左值还是右值.

```c++
template <typename T, typename Arg>
T create(Arg&& arg) {
    return T(std::forward<Arg>(arg));  // 保持 arg 的原始值类别
}

std::string s = "Test";
auto a = create<std::string>(s);       // 传递左值 → 调用拷贝构造
auto b = create<std::string>("Temp");  // 传递右值 → 调用移动构造
```

### C++的栈容器的内部是什么样的，内存是否连续？

C++的栈stack不是独立容器，是基于其他的序列容器的。默认是使用deque双端队列实现。

- deque内存连续，由多个固定大小内存块组成
- vector：完全连续，是开辟了一大块大的内存块用于使用
- list：非连续，双休链表节点分散存储

### shared_ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？

引用计数的**核⼼原理**：

- 在shared_ptr的内部维护了⼀个计数器，来跟踪有多少个shared_ptr对象指向了某⼀个资源。当计数器的值减少到0的时候，shared_ptr就会调⽤delete(或者⽤户⾃定义的⽅法)来释放资源。

引用计数器何时**增加**：

- 新建⼀个shared_ptr并指向了⼀个资源时。
- 复制构造函数创建⼀个新的shared_ptr时。
- ⽤复制运算符将⼀个shared_ptr给另⼀个shared_ptr对象赋值时。

引⽤计数器何时**减少**：

- 当⼀个shared_ptr对象被销毁时，⽐如局部变量离开作⽤域，或者类成员变量析构时。2.
- 当⼀个shared_ptr对象不再指向⼀个资源时，例如通过reset⽅法或者赋值运算符指向另⼀个资源时。

### 讲一下循环引用如何发生的，以及如何解决？

在两个或多个对象相互引用，或者⼀些复杂的数据结构，如图，双向链表中，存在多个引⽤路径等情况下，可能会存在循环引用问题，导致资源无法被释放掉。这个时候就需要使用weak_ptr来打破循环引⽤。因为使⽤weak_ptr指向某⼀个资源时，它不会增加这个资源的引⽤计数。

```c++
#include <iostream>
#include <memory>

// 前向声明
class NodeB;

class NodeA {
public:
    // 使用 shared_ptr 会导致循环引用
    std::shared_ptr<NodeB> b_ptr;
    // 解决方案：使用 weak_ptr 替代
    // std::weak_ptr<NodeB> b_ptr;
    
    ~NodeA() { std::cout << "NodeA 销毁\n"; }
};

class NodeB {
public:
    std::shared_ptr<NodeA> a_ptr;
    ~NodeB() { std::cout << "NodeB 销毁\n"; }
};

int main() {
    // 创建两个节点
    auto a = std::make_shared<NodeA>();
    auto b = std::make_shared<NodeB>();
    
    // 建立相互引用
    a->b_ptr = b;  // shared_ptr 版本会导致循环引用
    b->a_ptr = a;
    
    std::cout << "a 引用计数: " << a.use_count() << "\n";
    std::cout << "b 引用计数: " << b.use_count() << "\n";
    
    // main 结束时，a 和 b 应该被销毁...
    // 但如果使用 shared_ptr，由于循环引用，引用计数不会归零
    // 只有使用 weak_ptr 才能正确销毁
    
    return 0;
}
```

### shared_ptr是线程安全的吗？多线程中使用智能指针要注意什么？

- 多线程代码操作的是同一个shared_ptr的对象是线程不安全的。
- 多线程代码操作的不是同一个shared_ptr的对象，但不同的shared_ptr指向了相同的内存，此时是线程安全的。

### 何时用shared_ptr，何时用weak_ptr?

在我们需要对引用的资源进行指针之间的共享的时候，我们通常会使用shared_ptr。在使用shared_ptr，weak_ptr会作为一个配合它使用的辅助指针来使用，使用到weak_ptr的场景通常有两种。

- 在使用shared_ptr时，我们要解决循环引用的问题，这时我们要用weak_ptr来打破循环引用的问题，避免资源无法被释放。
- 当我们需要使用一个共享的内存，但是从业务逻辑上来讲，这个持有不应该对这个资源的生命周期有影响，这时我们也应该使用weak_ptr而不是用shared_ptr。

### 介绍⼀下static和const

**Const**:

- 基本概念：Const允许我们指定⼀个语义约束, 告诉编译器某个对象不应该被改变。而编译器会强制帮助我们实施这⼀项约束。如果我们认定某个值不能被改变，那么我们就应该使用const，来让编译器帮助我们来保证这个条件不被违反。
- 适用场景：const可以修饰很多内容。对于普通对象，可以修饰局部的，全局的，或者区块作⽤域中的普通对象；对于函数，可以修饰函数的返回值，函数的参数；对于指针，可以修饰指针本身（指针常量），也可以修饰指针所指的对象（常量指针）；对于类，可以修饰类的成员变量，也可以修饰类的成员函数。

**Static**:

C++中的static关键字具有多种用途。可以声明静态成员变量，静态成员函数，静态局部变量，静态全局变量。

- 静态成员变量和函数：是类的所有对象共享的成员变量。它们不属于任何特定的对象，而属于类本身。静态成员变量在类的所有对象之间只有⼀个实例。
- 静态成员函数：静态成员函数是不依赖于类的任何特定对象的成员数据。它们可以在没有类的对象的情况下调用。
- 静态局部变量：静态局部变量是在函数内部声明的静态变量，它与普通局部函数的变量不同，静态局部变量在程序运⾏期间只初始化⼀次，即使函数被多次调用。
- 静态全局变量：静态全局变量是全局作用域内声明的静态变量。它们的可用性仅限于定义它们的源文件，意味着它们不能在其它源文件中访问，有助于封装和避免命名冲突。

### 如何让对象只能产⽣于栈/堆中

对象只产生于栈中：

- 将对象的operator new设置为私有的。这个时候使⽤new尝试在堆上分配内存无法编译通过，就将内存的分配限制了只能分配在栈上。

对象只产生于堆中：

- 将对象的析构函数设置为私有的，因为在栈上分配对象的时候，编译器会自动调用对象的构造函数和析构函数，因此此时如果在栈上分配内存会编译报错，就将内存限制在了只能分配在堆上。

### new和malloc的区别

- 性质不同：new是⼀个c++中特有的操作符，⽽malloc是c语⾔中的内存分配函数。New只能在c++中 使⽤，但是malloc在c++和c中都可以使⽤。
- 内存分配⽅式不同：malloc分配的内存是未初始化的，⽽new不仅分配了内存，还调⽤了对象的构造函数来初始化对象。
- 使⽤语法不同：malloc使⽤时需要指定分配内存的⼤⼩，如malloc(sizeof(int)), 但new不⽤，使⽤更加简洁，如：new int
- 返回类型：malloc返回void*类型指针，需要强制转换成其它指定类型，⽽new直接返回响应的数据类型的指针，无需类型转换。
- 错误处理：内存分配失败后，malloc返回null, ⽽new会抛出std::bad_malloc异常。
- 配对操作：malloc分配内存使用free释放，⽽new分配内存要使用delete释放。

### 什么是左值？什么是右值？

- 左值⼀般是指向⼀个指定内存的，具有名称的值，它通常拥有⼀个稳定的内存地址，并且有⼀段较长时间的声明周期。左值能取到地址。
- 右值通常是不指向稳定内存地址的匿名值，声明周期很短，通常是暂时的。基于此特性，可以用取地址符来判断，右值不能取到地址。

### C和C++的区别？

 C++是C加上⼀些⾯向对象的特性。最初C++只是C加上⼀些⾯向对象的特性，但随着语⾔的发展，C++⽀持了更多观念和特性，变得⽐C语⾔更具有弹性和灵活性。现在的C++相⽐C，是⼀个语⾔联邦，它包含了C语⾔，但具有更多特性。

- .C++以C为基础，包含了C语⾔部分。区块，语句，预处理器，内置数据类型，数组，指针等特性都是来⾃于C。
- C++包含了⾯向对象的特性，⽐如封装，继承，多态，virtual函数的特性。
- C++包含了泛型编程的部分。
- C++包含了STL部分。
总之，C++是在C语⾔基础上，包含了其它特性⽽发展⽽来的，相⽐C语⾔来说更加灵活和复杂。

### 前置++返回的是左值还是右值，后置++呢？字符串字面量呢?

- 前置++的实现是直接对传入的对象自增，然后将此对象返回，因此它返回的是⼀个具有名称的稳定的**左值**。
- 后置++的实现是创建⼀个临时对象，然后对传入的对象自增，然后返回的是⼀个这个临时的对象，因此它返回的是⼀个**右值**。
- 字符串变量也是⼀个左值，因为它会将字符串变量存储到程序的数据段中，程序加载时会为它开辟内存空间，所以我们可以⽤&取地址，所以是左值。

### 右值引用是如何提⾼性能的？

右值引⽤主要是通过避免不必要的拷贝操作来提高代码的性能的。

### 介绍⼀下RVO？
RVO（ReturnValueOptimization）是⼀种编译器优化技术，用于消除不必要的临时对象拷贝，提高代码的性能。RVO主要针对函数返回局部对象的情况，通过优化，可以避免创建临时对象并执行拷贝构造函数。
RVO的**基本思想**是：在函数调用栈上直接构造返回值，而不是先构造⼀个局部对象，然后再拷贝到调用者的栈空间。这样可以减少临时对象的创建和销毁，提高代码的运行效率。

### 如果一个class的this指针被删除后强行访问会有什么影响？

会出现崩溃或者输出乱码值
```c++
#include <iostream>
using namespace std;
class C
{
public:
    int data = 42; // 假设有一个成员变量
    void destroy()
    {
        delete this; // 销毁对象
    }
};

int main()
{
    C *obj = new C();
    obj->destroy();
    cout << "强行访问 obj->data: " << obj->data << endl;
    return 0;
}
```

输出结果：
![alt text](image.png)

### volatile关键字的作用？

volatile关键字的作用就是防止编译器优化，编译器每次读变量的值都从内存直接读取最新值且写操作时直接写入内存。该关键字不保证线程安全。如果目的是实现原子操作推荐atomic。
适用场景：

- 硬件寄存器访问：硬件寄存器的值可能被外部设备随时修改（如传感器、GPIO 状态）
- 中断服务程序（ISR）与主程序共享变量：中断可能异步修改变量（如标志位），主程序需感知最新值
- 多线程环境中的简单标志位：用于线程间通知（如退出标志），但不保证线程安全
- 防止空循环被优化

### C++的内存对齐？

C++中的内存对齐​（Memory Alignment）是一种由编译器自动实施的内存优化机制，其核心目的是**提升CPU访问内存的效率**，并确保数据在特定硬件架构上能够安全访问。
目的：

- **性能优化**：CPU访问对齐的内存（如4字节数据起始地址为4的倍数）通常只需一次内存操作；若未对齐，则可能触发多次访问或硬件异常，尤其在RISC架构。
- 硬件兼容性：某些处理器（如SPARC、早期ARM）要求数据严格对齐，否则抛出硬件异常。在ARM64上，normal memory非对齐访问不会有问题。但是device memory非对齐访问会报bus error

内存对齐一般是按从大到小的顺序去对齐的。这样可以减少内存对齐所填充的字节数，优化空间。C++的类的虚指针也会参与内存对齐。

### C++函数封装器为什么优于函数指针？

函数封装器的优点：

- 函数封装器兼容函数指针，lambda表达式和仿函数，代码更加简洁、清晰且利于拓展。
- 函数封装器类型安全，有严格的类型检查。
- 与现代C++特性的深度集成
- 面向对象支持

### strcpy的缺点是什么？

- strcpy会造成缓冲区溢出并导致不确定的问题。
- strcpy会导致软件漏洞容易被利用。轻则导致程序崩溃，重则导致黑客找到存储器上返回地址的值，替换为恶意程序。

### class和struct的区别？

- class的默认成员和继承都是private的，如果要存储一些内部使用的成员变量推荐使用class,因为内部的一些数据不希望被外部随意获取。
- struct默认是public的，如果是要给外部提供一些所需的数据可以使用struct。

### C++中switch和if else的区别在哪里？

- switch只支持整数和枚举类型，如果是仅仅使用整数和枚举类型的逻辑判断，使用switch的性能更佳。编译器会生成一个跳转表给switch语句。考虑代码可读性推荐使用。
- if else可以判断所有的逻辑类型。if else使用遍历的方法。理论上性能会差一点，但是编译器优化后，只要分支不超过100个，switch的性能和if else性能接近。

### C++ inline内联的作用？

- inline内联即直接把该部分的代码复制到调用处，这样就不会有代码调用的call的开销，提高代码的性能，但是会导致代码膨胀，降低编译速度。C++17开始容许多次定义，即2个不同的C++文件中的同名inline内联函数可以实现不同的功能，类似static，对别的C++文件屏蔽该函数。如果在同一个C++文件中设置2个同名内联函数，在链接阶段会出现一个情况，即随机挑选一个函数链接上。(但是我试了一下使用gcc编译这种情况是没办法编译成功的)

### 虚函数和纯虚函数的区别？

- 虚函数是实现C++运行时多态的核心机制，通过virtual关键字声明，当通过基类指针或引用调用虚函数时，会根据对象的实际类型动态绑定到正确的函数实现。虚函数可以有默认实现，派生类可以选择性重写，包含虚函数的类可以实例化。
- 纯虚函数通过在虚函数声明后加=0定义，没有默认实现，强制派生类必须重写。包含纯虚函数的类称为抽象类，不能实例化，纯虚函数用于定义接口规范，确保所有派生类都有该功能。
代码：

```c++
#include <iostream>
usingnamespacestd;

class Animal {
public:
    virtual void speak() {  // 虚函数，有默认实现
        cout << "Animal sound" << endl;
    }
    virtual ~Animal() {}  // 虚析构函数
};

class Dog :public Animal {
public:
    void speak() override {  // 重写虚函数
        cout << "Woof!" << endl;
    }
};

int main() {
    Animal* animal = new Dog();
    animal->speak();  // 输出: Woof!
    delete animal;
    return0;
}
```
```c++
#include <iostream>
usingnamespacestd;

class Shape {// 抽象基类
public:
    virtual void draw() = 0;  // 纯虚函数，无实现
    virtual ~Shape() {}
};

class Circle :public Shape {
public:
    void draw() override {  // 必须实现纯虚函数
        cout << "Drawing a circle" << endl;
    }
};

int main() {
    // Shape shape;  // 错误: 不能实例化抽象类
    Shape* shape = new Circle();
    shape->draw();  // 输出: Drawing a circle
    delete shape;
    return0;
}
```

### 怎么解决菱形继承？

C++具备多重继承，导致会出现菱形继承的问题。
一个子类继承自多个父类，多个父类本身也可以继承自同一个基类。
菱形继承会导致二义性，存储空间浪费的问题。
解决方法：

- 虚继承：子类只继承一次父类的父类。在中间基类继承父共同基类时加上virtual关键词。其实现原理就是**依靠虚基类表**，编译器为每个虚继承的类生成一个虚基类指针，指向这个虚基类表。虚基类表存储偏移量，用于在运行时定位共享基类成员的位置对象。

```c++
class Derived1 : virtual public Base {}; // 虚继承
class Derived2 : virtual public Base {}; // 虚继承
class MostDerived : public Derived1, public Derived2 {};
```

### override和final关键字的作用？

解决不能阻止某个虚函数进一步重写的问题。
override:显式标记派生类中的函数是对基类虚函数的覆盖（重写），并强制编译器检查函数签名是否完全匹配。核心机制是签名检查(编译器验证派生类函数的签名是否与基类虚函数一致）和避免假重写。
final:禁止类被继承或虚函数被进一步重写，锁定设计意图。修饰类则类不可被继承。修饰虚函数则虚函数在派生类中不可再被重写。

```c++
class Base {
public:
    virtual void print(int x) const; // 基类虚函数
};
class Derived : public Base {
public:
    void print(int x) const override; // ✅ 正确覆盖
    void print(double x) override;    // ❌ 编译错误：参数类型不匹配
};
```

```c++
class Base {  
public:  
    virtual void foo() final;  
};  
class Derived : public Base {  
    void foo() override; // ❌ 编译错误：foo是final的[3,9](@ref)  
};  
```

### C++类型推导的作用和用法？

C++作为一种强类型语言，类型匹配比较麻烦，所以借助编译器来处理类型推导比较好，提升编码效率。
**auto**：用于变量的类型的推导，初始化一个值然后去推导变量的类型。如果是使用auto定义多个变量，多个变量必须是同一类型。类型推导会丢失引用和cv语义，可以使用auto&保留，万能引用auto&&,会根据初始值属性判断是左值还是右值引用。常见于lambda表达式。
**decltype**:推导表达式的类型（保留所有信息)

```c++
int a = 10;
decltype(a) b = 20;     // b 为 int
decltype(a + 3.14) c;   // c 为 double[5](@ref)
```

### function,lambda,bind之间的关系？

​Lambda 和 std::bind 是生产者，生成可调用的对象。function是消费者，管理各类对象并提供一致的调用接口。

- function：通用可调用对象的包装器，支持类型擦除，统一存储 Lambda、std::bind 结果等。依赖其他可调用对象作为其内容。
- lambda：生成匿名函数对象（闭包），可捕获外部变量，提供简洁的语法定义临时函数。可独立使用，或作为 std::function/std::bind 的输入。优点是直接内联，系统开销小。
- bind：绑定函数的部分参数，生成新的可调用对象，支持参数重排和占位符机制。常常绑定普通函数、成员函数或 Lambda。

### 继承下的构造函数和析构函数执行顺序？

继承下，构造函数按照依赖链，从上到下进行构造，析构函数是自下往上进行析构。

### 虚函数表和虚函数表指针的创建时机？

- 虚函数表的创建时机：**编译期生成**。当编译器检测到类中包含 virtual 关键字修饰的虚函数（或继承自基类的虚函数）时，会为该类生成一个虚函数表。虚函数表是一个函数指针数组，按虚函数在类中的声明顺序存储其地址。若派生类重写了基类虚函数，则表中存储派生类函数的地址；未重写则保留基类函数地址。
- 虚函数表指针的创建时机：**运行期**对象构造时初始化​。vptr 是对象级别的成员，每个对象独立拥有。它在对象构造阶段被初始化，由编译器在构造函数中插入代码完成。vptr 位于对象内存布局的起始位置，指向所属类的虚函数表。

### 虚析构函数的作用？

虚析构函数的作用：

- **确保完整的析构链调用**：当基类指针指向派生类对象时，若基类析构函数未声明为虚函数，delete该指针只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类独有的资源（如动态内存、文件句柄等）无法释放，引发内存泄漏或资源泄漏。虚析构函数通过动态绑定机制，确保delete基类指针时，先调用派生类析构函数，再调用基类析构函数，形成完整的析构链。

虚析构函数的**适用场景**：

- ​多态基类必须使用虚析构
- ​抽象接口类
- 含动态资源的派生类

### C++11有哪些主要特性？

C++11主要特性：

- 1.类型推导
- 2.智能指针
- 3.右值引用和移动语义
- 4.constexpr 编译时计算

### 动态库和静态库的区别？

- 静态库​：通过编译器生成目标文件，再用归档工具打包成.a或.lib文件。编译时直接嵌入库代码，符号在链接阶段解析完成。适合嵌入式系统或离线环境。程序启动时**自动加载**。牺牲空间换取独立性和启动速度，适合封闭环境或资源隔离需求。
- ​动态库​：编译时添加-fPIC（位置无关码）和-shared选项，生成.so或.dll文件。运行时通过动态加载器解析符号地址。运行时通过API**手动加载**。牺牲部署复杂度换取灵活性和资源共享，适合模块化系统或高频更新场景。

### 右值引用和左值引用的区别？

**左值引用**的作用​：

- ​减少拷贝​：作为函数参数或返回值时避免数据复制。
- ​修改原对象​：通过引用直接操作原始数据。
- ​生命周期管理​：const T& 可延长临时对象的生命周期至引用作用域结束。

**右值引用**的作用：

- 通过“窃取”临时对象的资源（如堆内存），避免深拷贝。
- 完美转发：在模板中保持参数的原始值类别（左值/右值），通过forward转发。

```c++
template<typename T>
void wrapper(T&& arg) {
    target(std::forward<T>(arg)); // 保留左值/右值属性
}
```

### C++什么时候生成默认拷贝构造函数？

默认拷贝构造函数（执行浅拷贝）在以下四种情况下会被编译器自动生成：

- 类成员包含有拷贝构造函数的类对象
- 类继承自有拷贝构造函数的基类
- 类包含虚函数
- ​类存在虚继承

### C++类型推导为什么会有额外的开销？

C++的类型推导之所以会有额外的开销，是因为以下几个原因：

- 1.推导规则复杂：auto会忽略初始化表达式的顶层const、引用和数组退化。需编译器多步分析。decltype的值类别敏感，需根据表达式是变量、函数调用或带括号的左值，分别应用不同规则推导。
- 2.模板实例化负担：在模板中使用auto或decltype推导返回值时，可能触发多次模板实例化。
- 3.​意外的值拷贝:若初始化表达式返回引用，但auto未显式声明引用，会进行值拷贝。

### C++如何搜索链接到so动态库中的符号的？

C++链接到动态库的过程：

- 1. ​动态库加载与初始化：操作系统通过 mmap 将库文件映射到进程地址空间，动态链接器解析库的依赖关系，递归加载所有依赖库。
- 2. 符号查找顺序：动态链接器按固定顺序解析符号，先加载主程序符号表，再进行广度搜索逐层加载动态库，最后加载全局符号表
- 3. 使用符号绑定机制：符号绑定机制分为立即绑定和延迟绑定，延迟绑定通过全局偏移表实现符号的解析。

### vector与普通数组的区别？vector扩容如何影响复杂度？

vector和数组的区别在于：vector是动态大小，能够自动管理堆内存，有边界检查，并提供了一些功能接口。vector扩容时会将老的元素复制到新开辟的内存空间中，频繁扩容会导致性能下滑。

### 进程同步的技术有哪些？

进程同步技术主要用于协调多个进程对共享资源的访问，避免竞态条件（Race Condition）和数据不一致问题。

- 互斥锁：通过锁定机制确保同一时刻只有一个进程能访问临界区资源。适用于简单共享资源的**独占访问**。

```c++
std::mutex mtx;
void critical_section() {
    std::lock_guard<std::mutex> lock(mtx); // 自动加锁
    // 访问共享资源
} // 自动解锁
```

- ​信号量：通过计数器控制**多个进程**对共享资源的访问权限。适用于资源池的管理。

```c++
#include <semaphore>
std::counting_semaphore<10> sem(3); // 允许3个进程同时访问
void access_resource() {
    sem.acquire(); // 获取信号量
    // 使用资源
    sem.release(); // 释放信号量
}
```

- 条件变量：允许进程等待特定条件成立后再继续执行，需与互斥锁配合使用。通过wait()释放锁并阻塞，通过notify_one()或notify_all()唤醒等待进程。

```c++
std::mutex mtx;
std::condition_variable cv;
bool data_ready = false;

void consumer() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return data_ready; }); // 等待条件满足
    // 消费数据
}
```

- 屏障：强制多个进程在指定同步点等待，直到所有进程到达后才继续执行。主要适用于并行计算中分阶段任务等场景。

```c++
#include <barrier>
std::barrier sync_point(5); // 等待5个进程

void worker() {
    // 阶段1任务
    sync_point.arrive_and_wait(); // 同步点
    // 阶段2任务
}
```

- 原子操作：通过硬件指令保证对单个变量的操作不可分割，避免数据竞争。主要适用于高频计数器、无锁数据结构等场景。

```c++
#include <atomic>
std::atomic<int> counter(0);

void increment() {
    counter.fetch_add(1, std::memory_order_relaxed);
}
```

- 读写锁：允许多个进程同时读取共享资源，但**写入时需独占访问**。适用于读多写少的共享数据（如配置信息）。

```c++
#include <shared_mutex>
std::shared_mutex rw_mutex;

void read_data() {
    std::shared_lock lock(rw_mutex); // 共享锁（可并发读）
    // 读取数据
}

void write_data() {
    std::unique_lock lock(rw_mutex); // 独占锁（互斥写）
    // 写入数据
}
```

### malloc和new的具体实现？

- malloc是C标准库函数，其核心是通过操作系统提供的系统调用管理堆内存。使用分配的内存块头部存储元数据，通过链表链接所有空闲块。
- new是C++运算符，其行为包含内存分配和对象构造两阶段，内存分配阶段调用全局operator new函数，默认实现内部调用malloc。对象构造阶段用placement new在已分配内存上调用构造函数。

```c++
void* memory = operator new(sizeof(MyClass));  // 调用malloc分配内存
MyClass* obj = new (memory) MyClass();    // 在memory地址调用构造函数
```

### 不相关的进程间能否使用管道实现通信？

不相关的进程之间可以通过**命名管道**实现通信。
命名管道：
命名管道通过 mkfifo() 或 mknod() 系统调用创建，在文件系统中生成一个特殊的 ​FIFO 文件​（如 ./myfifo）。该文件不存储实际数据，仅作为内核中管道缓冲区的访问入口。
任何进程只要知道该文件路径，即可通过 open() 打开管道进行读写，无需亲缘关系。进程以写模式（O_WRONLY）打开管道，调用 write() 向管道写入数据。另一进程以读模式（O_RDONLY）打开管道，调用 read() 从管道读取数据。

### 协程是什么？

C++协程（Coroutine）是C++20引入的一种轻量级并发编程机制，它允许函数在执行过程中暂停（挂起）并在稍后恢复，而无需依赖操作系统线程调度，从而简化异步编程、提高资源利用率。
协程是一种特殊函数，可在执行中主动挂起，保存当前状态（局部变量、执行位置等），后续通过协程句柄恢复执行。
C++20采用**无栈协程模型**，挂起时将上下文（局部变量、寄存器状态）存储在堆上

### C++的重载和C语言的区别在哪里？具体是如何实现？

- C++重载的实现原理是**名字修饰**。汇编阶段使用修饰名生成符号，不同参数列表对应独立符号。C++重载在编译阶段生成唯一符号，链接阶段解析符号，重载解析符号，调用函数时，编译器选择参数最匹配的重载版本。
- C语言：汇编阶段仅用函数名生成符号，同名函数导致符号重复定义。链接阶段C链接器按函数名查找地址，无法区分重载函数。

### C和C++编译出来的文件有什么区别？

和C++编译生成的可执行文件（如ELF、PE格式）在格式层面是兼容的（均可由操作系统加载执行），但因其语言特性差异，**二进制内容**存在显著区别。

- 编译器通过名字修饰将函数名、参数类型/数量/顺序编码为唯一符号。C语言仅用函数名标识符号。
- 异常处理与运行时类型信息(RTTI)：编译器在二进制中插入异常处理框架​（如try/catch的栈回退逻辑）和RTTI数据结构​（用于dynamic_cast和typeid），以支持面向对象特性。C语言没有。
- 函数调用约定与对象模型：C++成员函数调用隐含传递this指针（通常通过寄存器或栈），而C函数无此机制。C++在main()前/后插入全局/静态对象的构造/析构代码，而C程序仅按代码顺序执行。
