# C++八股文

### C++指针和引用的区别？

在 C++中，引用本身并不占用额外的内存空间。当你传递一个变量作为引用参数给函数时，函数内部会使用该引用来直接操作原始变量，而不是创建原始变量的副本。因此，使用引用可以避免不必要的数据复制，提高程序的效率。引用的内部实现通常是通过指针来完成的，因此在函数调用时，引用本身并不会在栈上分配额外的内存空间，只是会使用一个指针来指向原始变量的内存地址。总结起来，引用不占用函数栈内存，但会占用一个指针的大小。
指针与引用的区别：

- 指针本身是一个对象，允许进行赋值和拷贝等操作。
- 指针的生命周期内可以指向几个不同的对象，引用不可以。
- 指针不需要在定义时赋初值。
需要注意的是，引用在底层实现上通常被编译器实现为指针，但是在使用时更类似于被引用的变量本身。引用在编译时会被转换为指针。引用在被使用的使用会占用4个字节大小的内存空间，也就是一个指针的大小

### C++多态的实现

C++的多态分为静态多态和动态多态。

- 静态多态的实现原理是函数重载和模板函数。函数重载指的是在同一个作用域内，可以定义多个函数，它们具有相同的名称但参数列表不同的情况。在调用这些函数时，编译器会根据函数调用时提供的参数类型和数量来确定调用哪个函数。模板函数是指在定义函数时使用了类型参数，让函数适用于多种不同的类型。编译器在编译时根据参数类型生成具体的函数实现。模板函数的实现是通过编译时的模板实例化来实现的。
- 动态多态指的是在运行时根据对象的实际类型确定要调用的函数。动态多态实现的原理是虚函数和抽象类。虚函数是指在基类中定义的函数可以被派生类重写的函数。通过将函数声明为虚函数，我们可以在运行时根据对象的实际类型来确定要调用的函数实现。在C++中，只要将函数声明为虚函数即可实现动态多态。抽象类是指包含至少一个纯虚函数的类，这个类不能被实例化，只能用作基类来派生出其他类。在C++中，可以通过将函数声明为纯虚函数来实现抽象类。

### C++的构造函数能否定义为虚函数？

不能。

- 虚函数通过虚表实现多态，每个类内存有一个虚表，表内存放虚指针。这个虚指针是构造对象时被初始化的。

- **虚函数的工作机制**：虚函数通过虚函数表（vtable）来实现多态。每个包含虚函数的类都有一个虚函数表，其中存放了指向该类虚函数的指针。每个对象在创建时，会有一个指向其虚函数表的指针（vptr）。这个vptr是在对象构造期间被初始化的。从构造函数的**调用时序**看，在构造一个派生类对象时，首先调用基类的构造函数，然后依次调用派生类的构造函数。在基类构造函数执行期间，对象的类型是基类类型，而不是派生类类型。C++语言标准明确规定，构造函数不能是虚函数。如果你尝试在构造函数声明前加上virtual关键字，编译器会报错。

### 智能指针有没有了解？shared_ptr和unique_ptr讲一下

智能指针的实现是利用了RAII的技术对普通指针进行封装，使得智能指针本质上是一个对象，却表现出一个指针的行为。智能指针的**作用**是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存，解决多次释放同一指针造成崩溃的问题。智能指针还可以把值语义转换成引用语义。

智能指针的内存问题：智能指针位于栈区域，它管理的对象是位于堆区域。堆区域是程序运行时内存动态分配的地方，智能指针指向堆上的对象，当不再需要这个对象时会自动释放内存。

- shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁，因为shared_ptr的指向对象部分并不是线程安全的。
- unique_ptr独占其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。与原始指针相比，unique_ptr由于其RAII的特性，使得在出现异常的情况下，动态资源仍然能得到释放。
- weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。C++11中被废弃。

### 对锁有没有了解，介绍一下？

- mutex:最基本的互斥锁，不可重入
- recursive_mutex：可重入互斥锁，允许同一线程多次加锁
- timed_mutex：带超时功能的互斥锁，尝试获取锁一段时间，超时则返回。
- recursive_timed_mutex：可重入且支持超时
- shared_mutex：读写锁，支持两种访问模式，适用于读多写少的场景。
- shared_timed_mutex：shared_mutex基础上增加了超时功能

### C++移动语义move的作用？

move作用主要是可以将一个左值转换成右值引用，可以调用C++11右值引用的拷贝构造函数，在对象拷贝的时候，在运行时，move函数可以减少资源创建和释放。

```c++
#include <utility>
int main() {
    int x = 42;
    int y = std::move(x); // 将 x 转换为右值引用，不会进行拷贝操作
    return 0;
}
```

### move和forward的区别？

- move:将对象无条件转换为右值引用，启用移动语义.无论接受左值还是右值，都返回右值引用。实质是静态类型转换：static_cast<T&&>(t)

```c++
std::string s1 = "Hello";
std::string s2 = std::move(s1);  // 移动构造，s1 变为空
```

- forward:在模板中完美转发参数，保持原始值类别（左值/右值）。仅在模板中使用（通常是通用引用 T&&）。根据模板参数T的类型决定转发为左值还是右值.

```c++
template <typename T, typename Arg>
T create(Arg&& arg) {
    return T(std::forward<Arg>(arg));  // 保持 arg 的原始值类别
}

std::string s = "Test";
auto a = create<std::string>(s);       // 传递左值 → 调用拷贝构造
auto b = create<std::string>("Temp");  // 传递右值 → 调用移动构造
```

### C++的栈容器的内部是什么样的，内存是否连续？

C++的栈stack不是独立容器，是基于其他的序列容器的。默认是使用deque双端队列实现。

- deque内存连续，由多个固定大小内存块组成
- vector：完全连续，是开辟了一大块大的内存块用于使用
- list：非连续，双休链表节点分散存储

### shared_ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？

引用计数的**核⼼原理**：

- 在shared_ptr的内部维护了⼀个计数器，来跟踪有多少个shared_ptr对象指向了某⼀个资源。当计数器的值减少到0的时候，shared_ptr就会调⽤delete(或者⽤户⾃定义的⽅法)来释放资源。

引用计数器何时**增加**：

- 新建⼀个shared_ptr并指向了⼀个资源时。
- 复制构造函数创建⼀个新的shared_ptr时。
- ⽤复制运算符将⼀个shared_ptr给另⼀个shared_ptr对象赋值时。

引⽤计数器何时**减少**：

- 当⼀个shared_ptr对象被销毁时，⽐如局部变量离开作⽤域，或者类成员变量析构时。2.
- 当⼀个shared_ptr对象不再指向⼀个资源时，例如通过reset⽅法或者赋值运算符指向另⼀个资源时。

### 讲一下循环引用如何发生的，以及如何解决？

在两个或多个对象相互引用，或者⼀些复杂的数据结构，如图，双向链表中，存在多个引⽤路径等情况下，可能会存在循环引用问题，导致资源无法被释放掉。这个时候就需要使用weak_ptr来打破循环引⽤。因为使⽤weak_ptr指向某⼀个资源时，它不会增加这个资源的引⽤计数。

```c++
#include <iostream>
#include <memory>

// 前向声明
class NodeB;

class NodeA {
public:
    // 使用 shared_ptr 会导致循环引用
    std::shared_ptr<NodeB> b_ptr;
    // 解决方案：使用 weak_ptr 替代
    // std::weak_ptr<NodeB> b_ptr;
    
    ~NodeA() { std::cout << "NodeA 销毁\n"; }
};

class NodeB {
public:
    std::shared_ptr<NodeA> a_ptr;
    ~NodeB() { std::cout << "NodeB 销毁\n"; }
};

int main() {
    // 创建两个节点
    auto a = std::make_shared<NodeA>();
    auto b = std::make_shared<NodeB>();
    
    // 建立相互引用
    a->b_ptr = b;  // shared_ptr 版本会导致循环引用
    b->a_ptr = a;
    
    std::cout << "a 引用计数: " << a.use_count() << "\n";
    std::cout << "b 引用计数: " << b.use_count() << "\n";
    
    // main 结束时，a 和 b 应该被销毁...
    // 但如果使用 shared_ptr，由于循环引用，引用计数不会归零
    // 只有使用 weak_ptr 才能正确销毁
    
    return 0;
}
```

### shared_ptr是线程安全的吗？多线程中使用智能指针要注意什么？

- 多线程代码操作的是同一个shared_ptr的对象是线程不安全的。
- 多线程代码操作的不是同一个shared_ptr的对象，但不同的shared_ptr指向了相同的内存，此时是线程安全的。

### 何时用shared_ptr，何时用weak_ptr?

在我们需要对引用的资源进行指针之间的共享的时候，我们通常会使用shared_ptr。在使用shared_ptr，weak_ptr会作为一个配合它使用的辅助指针来使用，使用到weak_ptr的场景通常有两种。

- 在使用shared_ptr时，我们要解决循环引用的问题，这时我们要用weak_ptr来打破循环引用的问题，避免资源无法被释放。
- 当我们需要使用一个共享的内存，但是从业务逻辑上来讲，这个持有不应该对这个资源的生命周期有影响，这时我们也应该使用weak_ptr而不是用shared_ptr。

### 介绍⼀下static和const

**Const**:

- 基本概念：Const允许我们指定⼀个语义约束, 告诉编译器某个对象不应该被改变。而编译器会强制帮助我们实施这⼀项约束。如果我们认定某个值不能被改变，那么我们就应该使用const，来让编译器帮助我们来保证这个条件不被违反。
- 适用场景：const可以修饰很多内容。对于普通对象，可以修饰局部的，全局的，或者区块作⽤域中的普通对象；对于函数，可以修饰函数的返回值，函数的参数；对于指针，可以修饰指针本身（指针常量），也可以修饰指针所指的对象（常量指针）；对于类，可以修饰类的成员变量，也可以修饰类的成员函数。

**Static**:

C++中的static关键字具有多种用途。可以声明静态成员变量，静态成员函数，静态局部变量，静态全局变量。

- 静态成员变量和函数：是类的所有对象共享的成员变量。它们不属于任何特定的对象，而属于类本身。静态成员变量在类的所有对象之间只有⼀个实例。
- 静态成员函数：静态成员函数是不依赖于类的任何特定对象的成员数据。它们可以在没有类的对象的情况下调用。
- 静态局部变量：静态局部变量是在函数内部声明的静态变量，它与普通局部函数的变量不同，静态局部变量在程序运⾏期间只初始化⼀次，即使函数被多次调用。
- 静态全局变量：静态全局变量是全局作用域内声明的静态变量。它们的可用性仅限于定义它们的源文件，意味着它们不能在其它源文件中访问，有助于封装和避免命名冲突。

### 如何让对象只能产⽣于栈/堆中

对象只产生于栈中：

- 将对象的operator new设置为私有的。这个时候使⽤new尝试在堆上分配内存无法编译通过，就将内存的分配限制了只能分配在栈上。

对象只产生于堆中：

- 将对象的析构函数设置为私有的，因为在栈上分配对象的时候，编译器会自动调用对象的构造函数和析构函数，因此此时如果在栈上分配内存会编译报错，就将内存限制在了只能分配在堆上。

### new和malloc的区别

- 性质不同：new是⼀个c++中特有的操作符，⽽malloc是c语⾔中的内存分配函数。New只能在c++中 使⽤，但是malloc在c++和c中都可以使⽤。
- 内存分配⽅式不同：malloc分配的内存是未初始化的，⽽new不仅分配了内存，还调⽤了对象的构造函数来初始化对象。
- 使⽤语法不同：malloc使⽤时需要指定分配内存的⼤⼩，如malloc(sizeof(int)), 但new不⽤，使⽤更加简洁，如：new int
- 返回类型：malloc返回void*类型指针，需要强制转换成其它指定类型，⽽new直接返回响应的数据类型的指针，无需类型转换。
- 错误处理：内存分配失败后，malloc返回null, ⽽new会抛出std::bad_malloc异常。
- 配对操作：malloc分配内存使用free释放，⽽new分配内存要使用delete释放。

### 什么是左值？什么是右值？

- 左值⼀般是指向⼀个指定内存的，具有名称的值，它通常拥有⼀个稳定的内存地址，并且有⼀段较长时间的声明周期。左值能取到地址。
- 右值通常是不指向稳定内存地址的匿名值，声明周期很短，通常是暂时的。基于此特性，可以用取地址符来判断，右值不能取到地址。

### C和C++的区别？

 C++是C加上⼀些⾯向对象的特性。最初C++只是C加上⼀些⾯向对象的特性，但随着语⾔的发展，C++⽀持了更多观念和特性，变得⽐C语⾔更具有弹性和灵活性。现在的C++相⽐C，是⼀个语⾔联邦，它包含了C语⾔，但具有更多特性。

- .C++以C为基础，包含了C语⾔部分。区块，语句，预处理器，内置数据类型，数组，指针等特性都是来⾃于C。
- C++包含了⾯向对象的特性，⽐如封装，继承，多态，virtual函数的特性。
- C++包含了泛型编程的部分。
- C++包含了STL部分。
总之，C++是在C语⾔基础上，包含了其它特性⽽发展⽽来的，相⽐C语⾔来说更加灵活和复杂。

### 前置++返回的是左值还是右值，后置++呢？字符串字面量呢?

- 前置++的实现是直接对传入的对象自增，然后将此对象返回，因此它返回的是⼀个具有名称的稳定的**左值**。
- 后置++的实现是创建⼀个临时对象，然后对传入的对象自增，然后返回的是⼀个这个临时的对象，因此它返回的是⼀个**右值**。
- 字符串变量也是⼀个左值，因为它会将字符串变量存储到程序的数据段中，程序加载时会为它开辟内存空间，所以我们可以⽤&取地址，所以是左值。

### 右值引用是如何提⾼性能的？

右值引⽤主要是通过避免不必要的拷贝操作来提高代码的性能的。

### 介绍⼀下RVO？
RVO（ReturnValueOptimization）是⼀种编译器优化技术，用于消除不必要的临时对象拷贝，提高代码的性能。RVO主要针对函数返回局部对象的情况，通过优化，可以避免创建临时对象并执行拷贝构造函数。
RVO的**基本思想**是：在函数调用栈上直接构造返回值，而不是先构造⼀个局部对象，然后再拷贝到调用者的栈空间。这样可以减少临时对象的创建和销毁，提高代码的运行效率。

### 如果一个class的this指针被删除后强行访问会有什么影响？

会出现崩溃或者输出乱码值
```c++
#include <iostream>
using namespace std;
class C
{
public:
    int data = 42; // 假设有一个成员变量
    void destroy()
    {
        delete this; // 销毁对象
    }
};

int main()
{
    C *obj = new C();
    obj->destroy();
    cout << "强行访问 obj->data: " << obj->data << endl;
    return 0;
}
```

输出结果：
![alt text](image.png)

### volatile关键字的作用？

volatile关键字的作用就是防止编译器优化，编译器每次读变量的值都从内存直接读取最新值且写操作时直接写入内存。该关键字不保证线程安全。如果目的是实现原子操作推荐atomic。
适用场景：

- 硬件寄存器访问：硬件寄存器的值可能被外部设备随时修改（如传感器、GPIO 状态）
- 中断服务程序（ISR）与主程序共享变量：中断可能异步修改变量（如标志位），主程序需感知最新值
- 多线程环境中的简单标志位：用于线程间通知（如退出标志），但不保证线程安全
- 防止空循环被优化

### C++的内存对齐？

C++中的内存对齐​（Memory Alignment）是一种由编译器自动实施的内存优化机制，其核心目的是**提升CPU访问内存的效率**，并确保数据在特定硬件架构上能够安全访问。
目的：

- **性能优化**：CPU访问对齐的内存（如4字节数据起始地址为4的倍数）通常只需一次内存操作；若未对齐，则可能触发多次访问或硬件异常，尤其在RISC架构。
- 硬件兼容性：某些处理器（如SPARC、早期ARM）要求数据严格对齐，否则抛出硬件异常。在ARM64上，normal memory非对齐访问不会有问题。但是device memory非对齐访问会报bus error

内存对齐一般是按从大到小的顺序去对齐的。这样可以减少内存对齐所填充的字节数，优化空间。C++的类的虚指针也会参与内存对齐。

### C++函数封装器为什么优于函数指针？

函数封装器的优点：

- 函数封装器兼容函数指针，lambda表达式和仿函数，代码更加简洁、清晰且利于拓展。
- 函数封装器类型安全，有严格的类型检查。
- 与现代C++特性的深度集成
- 面向对象支持

### strcpy的缺点是什么？

- strcpy会造成缓冲区溢出并导致不确定的问题。
- strcpy会导致软件漏洞容易被利用。轻则导致程序崩溃，重则导致黑客找到存储器上返回地址的值，替换为恶意程序。

### class和struct的区别？

- class的默认成员和继承都是private的，如果要存储一些内部使用的成员变量推荐使用class,因为内部的一些数据不希望被外部随意获取。
- struct默认是public的，如果是要给外部提供一些所需的数据可以使用struct。

### C++中switch和if else的区别在哪里？

- switch只支持整数和枚举类型，如果是仅仅使用整数和枚举类型的逻辑判断，使用switch的性能更佳。编译器会生成一个跳转表给switch语句。考虑代码可读性推荐使用。
- if else可以判断所有的逻辑类型。if else使用遍历的方法。理论上性能会差一点，但是编译器优化后，只要分支不超过100个，switch的性能和if else性能接近。

### C++ inline内联的作用？

- inline内联即直接把该部分的代码复制到调用处，这样就不会有代码调用的call的开销，提高代码的性能，但是会导致代码膨胀，降低编译速度。C++17开始容许多次定义，即2个不同的C++文件中的同名inline内联函数可以实现不同的功能，类似static，对别的C++文件屏蔽该函数。如果在同一个C++文件中设置2个同名内联函数，在链接阶段会出现一个情况，即随机挑选一个函数链接上。(但是我试了一下使用gcc编译这种情况是没办法编译成功的)