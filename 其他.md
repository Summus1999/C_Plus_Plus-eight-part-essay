# 其他

## 如何排查C++代码在计算部分的性能瓶颈？

- 宏观定位热点区域
- 微观分析热点函数
- 代码级瓶颈定位
能使用的工具：
- perf
- Hotspot
- VTune
- valgrind内存分析工具

## 局部性原理是啥？

局部性原理（Principle of Locality）是计算机系统中最核心的**性能优化**理论基础，它揭示了程序访问内存的规律性模式。程序在执行过程中倾向于重复访问最近使用过的数据或其邻近数据。

- 时间局部性：如果某个数据被访问，不久的将来它很可能再次被访问
- 空间局部性：如果某个数据被访问，其邻近地址的数据很可能很快被访问

## 如何定位C++内存泄漏问题？C++如何避免内存泄漏问题？

定位手段：

- 使用Valgrind进行内存泄漏的基础检测。
- 使用 ASan 快速定位。
- Valgrind 深度分析。
- Heaptrack 可视化分析。

C++内存泄漏防范手段：

- 尽量使用智能指针，智能指针能够自动管理动态分配的内存，当不再需要时会自动释放，来避免程序员使用裸指针没有释放资源导致的内存泄漏的问题。
- 及时释放不再需要的内存。即使使用了智能指针，也要确保在不再需要内存时及时将其重置或销毁。这可以避免不必要的内存占用，并有助于更早地发现潜在的内存泄漏问题。
- 借助一些内存泄漏监测工具，或者自己对内存使用情况进行跟踪记录，来及时判断程序是否发生了内存泄漏，并且及时修正代码。

## gdb的watch是如何实现的？看的是内存地址还是检测值是否变化？

GDB 中的 watch 命令通过**监控指定内存地址的内容变化实现断点触发**，其核心原理分为硬件辅助和软件模拟两种方式。

- 硬件辅助实现：**依赖CPU调试寄存器**，现代处理器（如x86的DR0-DR7寄存器）支持设置内存访问断点，监视地址，watch 将目标变量或表达式的内存地址写入调试寄存器。当出现读写等操作时，触发SIGTRAP异常，GDB捕获该异常并暂停程序，显示变化前后的值。
- 软件模拟：当硬件不支持或寄存器不足时，GDB在每条指令执行后，对比目标地址的当前值与之前快照。

## core dump是什么，如何使用gdb看core dump文件？

Core dump（核心转储）是程序崩溃时操作系统自动生成的磁盘文件，它保存了程序崩溃瞬间的完整内存快照、寄存器状态、函数调用栈等上下文信息，相当于程序“事故现场的黑匣子。无需修改代码或添加日志，直接分析崩溃瞬间状态。

看core dump文件的过程：(需要编译时候带上符号)
先生成core dump文件

```bash
ulimit -c unlimited  # 解除大小限制
```

- 加载 core 文件
- 使用调试命令查看文件

## ⾯向对象设计的主要的原则?

- 依赖倒置原则(DIP)：⾼层模块（稳定）不应该依赖于底层模式（变化），⼆者都应该依赖于抽象。抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。（所说的依赖都是编译时依赖。A依赖B，意味着A编译的时候B需要存在A才能编译通过）
- 开放封闭原则(OCP):对扩展开放，对更改封闭。（尽可能地去扩展，⽽不要修改）类模块应该是可扩展的，但是不可修改。
- 单⼀职责原则：⼀个类应该仅有⼀个引起它变化的原因，变化的⽅向隐含着类的责任。4.
- Liskov替换原则：⼦类必须能够替换他们的基类。
- 接口隔离原则：不应该强迫客户依赖它们不用的方法。接口应该小而完备。
- 优先使⽤对象组合，⽽不是使用类继承：类继承通常为白箱复⽤，对象组合通常为黑箱复用。继承在某种程度上破坏了封装性，子类⽗类的耦合度⾼。⽽对象组合则只要求被组合的对象具有良好的外部接口，耦合度相对更低。7.
- 封装变化点：使用封装来创建对象之间的分界层，让设计者在⼀侧进行修改，而不会对另⼀侧产⽣不良的影响,实现层次的直接耦合。
- 针对接口编程，而不是针对实现编程：不将变量类型声明为某个特定的具体类，⽽是声明为某个接口。客户⽆需获知对象的具体类型，⽽是只需要知道对象所具有的接口。
