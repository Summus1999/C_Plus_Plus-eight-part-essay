# 计算机网络八股文

## TCP三次握手和四次挥手，为什么这么设计？

- 三次握手：在建立TCP连接时，cilent客户端向server服务器端发送一个SYN（同步）标志的数据包，服务器端收到后回复一个SYN和ACK（确认）标志的数据包，表示接收到了客户端的请求，并同意建立连接，最后客户端再发送一个ACK标志的数据包，表示连接已经建立。这样就完成了三次握手，建立了连接。
- 四次挥手：在终止TCP连接时，一方（假设是客户端）向另一方（服务器端）发送一个FIN（结束）标志的数据包，表示要关闭连接，另一方收到后会回复一个ACK标志的数据包，表示收到了关闭请求。然后另一方再发送一个FIN标志的数据包给第一方，表示同意关闭连接，最后第一方再发送一个ACK标志的数据包，表示接收到了对方的关闭请求。这样就完成了四次挥手，终止了连接。

## TCP出现三次挥手是什么情况，会有什么影响？

当第四次挥手（Client的ACK）丢失或Server未收到ACK时，会出现三次挥手的情况。
三次挥手的影响：

- Server端资源泄露,最终导致端口耗尽，无法提供服务。
- 后续连接异常
- 数据传输错误

## TCP三次握手的原因是什么？

TCP三次握手是**建立可靠网络连接**的核心机制。原因有三个：

- **防止历史连接初始化**(核心原因)
- 同步双方初始序列号：为数据包提供有序标识，解决乱序、重复、丢包问题
- 避免资源浪费

## OSI模型下每层常见的协议有哪些？

具体内容会在协议八股文内介绍，此外会有详细的协议的介绍。如果时间充足的话。
应用层：**HTTP/HTTPS**，**DHCP**
表示层：**TLS/SSL**
会话层：RPC，SSH
传输层：**TCP,UDP**
网络层：IP,ICMP,**OSPF/BGP**,**ARP**，**IPsec**
数据链路层：Ethernet,WiFi，VLAN，HDLC
物理层：IEEE 802.3

## TCP的拥塞控制算法有哪些，请你详细介绍这些算法？

TCP的拥塞控制算法从远到近主要有：慢启动，拥塞避免，快重传，快恢复，CUBIC​算法，BIC算法，Vegas​算法，Veno​算法，BBR算法

- 慢启动：初始阶段以指数级增长探测网络容量，避免突发流量冲击。指数增长易导致突发丢包，尤其在高带宽网络中。
- 拥塞避免：线性增长cwnd，避免过度占用带宽。平衡网络负载，避免拥塞恶化。
- 快重传：通过重复ACK快速检测丢包，避免等待超时。连续收到3个重复ACK就会触发。
- 快恢复：避免因单个丢包直接回到慢启动，维持较高传输效率。
- CUBIC算法：使用三次函数替代线性增长，高带宽网络中更平稳，**Linux默认算法**。
- BIC算法：二分搜索寻找最大可用带宽，通过增/减窗口逼近平衡点。适用于**长距离高速网络**。
- Vegas​算法：通过RTT变化预测拥塞。若实际吞吐量低于预期，减小cwnd。与基于丢包的算法竞争时处于劣势。
- Veno​算法：丢包事件 → 触发快重传 → cwnd减半 → 进入快恢复 → 收到新ACK后退出恢复。结合丢包和延迟信号，区分无线丢包与真实拥塞丢包。适用于**无线网络**
- BBR算法：基于带宽和延迟估计，主动避免缓冲区膨胀

## ARP 欺骗是什么，如何防范？

ARP欺骗是一种网络攻击手段，通过伪造IP-MAC映射关系，导致数据被劫持或网络中断，在界面上的表现为本来通信的双方通信时断时续。这个问题可以从三个角度来回答：

- 网络设备层防御：开启ARP表项固化，学习到合法的ARP表项之后，将其绑定到端口，后续ARP表项将不再更新直到ARP表项手动使其失效。或者使用ARP严格学习，如果是固定设备的话使用该方法每次去校验ARP表项的接口和VLAN信息等，或者在更新ARP表项前发送ACK请求，确认ARP表项的变更。打开ARP报文的深度检查检查以太帧头部和ARP报文内容是否匹配。也可以使用安全协议如IPSEC去防御，IPSEC会将内外网IP分开，在通信双方间建立安全隧道保证通信的安全可靠。
- 网络架构优化：划分VLAN缩小广播域，PPPoE认证替代ARP(很挫的一种方法)，交换机端口安全绑定
- 终端防护措施：静态ARP绑定，安装ARP防火墙

## 什么是ICMP协议?

ICMP是TCP/IP协议族中网络层的协议，主要用于传输网络层控制消息的协议来达到**对网络信息进行诊断**，以及**发送错误报告**的目的。
⽐如ping 和traceroute就是通过icmp来对评估⽹络连接质量以及揭示数据包在⽹络的传输路径的来达到网络信息诊断的目的的。比如当数据包⽆法到达目的地时，路由器或目标主机就会发送目的地不可达消息，有助于识别网络问题，通过这种方式来达到发送错误报告的目的。
举个例子，我要和同事的一台电脑进行通信。我会首先ping一下他的电脑，首次ping肯定是失败的，由于没有学到ARP表项，会通过ARP协议进行学习，将同事的IP地址和MAC地址的映射到本地的网络层，有一个ARP表存储的ARP表项，然后我就可以知道IP和对应的MAC地址，后续的PING出去的ICMP报文就可以顺利到达同事，成功通信。目前的ICMP分为ICMP4和ICMP6，对应IP协议的V4和V6版本。

## 如何解决TCP的粘包?

解决TCP的粘包问题有以下几个方法：

- 添加消息边界：在发送数据时，给数据包添加⼀个特殊的边界标识，比如换行符或特殊字符。接收方在接收数据时，根据数据标识堆数据包进行拆分。
- 使用定长消息：约定每个数据包的长度固定。如果数据长度不足，那么就用特定字符去填写。这个方法适合于数据包长度固定的场景，但是可能会导致数据传输的效率降低。(比较挫，一般其他的协议也不会使用这种办法)
- 添加消息头：在发送数据的时候，为数据包添加⼀个消息头，在消息头中包含数据包的长信息。(有点类似蓝牙的协议，蓝牙协议就是这么做的)接收⽅在接收数据时，先解析消息头，获取数据包长度，然后根据长度对数据包进行拆分。4
- 使⽤应⽤层协议：使⽤HTTP或者FTP等协议，这些协议都已经解决了粘包问题。

## TCP挥⼿过程中，为什么需要存在time_wait状态？

![TCP全程状态图](image-1.png)

- **防⽌错误接收历史报⽂**：如果立刻断开连接，那么有可能断开连接后，立刻复用了原来的ip地址和端口号进⾏了重新连接，上⼀次连接过程中发送的无效报⽂可能会在新的连接中到达，这时新的连接无法辨别出这个报⽂是上⼀次连接发送的报文，就可能会发⽣错误。
- 保证双⽅可以正常关闭：如果在客户端发送给服务端的ACK的报⽂丢失了，服务端会给客户端重传⼀个FIN,这个时间最长是2MSL， 客户端需要等待2MSL，判断在这个时间是否收到了服务端的重传的FIN的报⽂，如果收到了，客户端也要重传ACK报⽂，来保证双⽅正常关闭。

## 如何解决大量TIME_WAIT 状态的问题?

- 调整 MSL：减⼩最⼤报⽂段⽣存时间（MSL）的值，以减少TIME_WAIT状态的持续时 间。这样可以更快地释放 TIME_WAIT 状态的连接资源，但请注意，设置太⼩的MSL 值可能导致⽹络问题，如旧连接的数据包⼲扰新连接。
- 使⽤连接池：在客户端和服务器之间使⽤连接池，以便复⽤已经建⽴的TCP连接，⽽不是频繁地创建和关闭新连接。这可以显著减少TIME_WAIT状态的数量，同时提⾼应⽤程序的性能。
- 使⽤ SO_REUSEADDR 套接字选项：在某些情况下，可以在服务器端启⽤SO_REUSEADDR 套接字选项。这允许服务器在TIME_WAIT状态的连接上重新绑定和监听端口。但请注意，这种方法可能会导致新旧连接之间的数据包混淆，因此需要谨慎使用．
- 使⽤ SO_LINGER 套接字选项：在某些情况下，可以在客户端启⽤SO_LINGER套接字选项，并将延迟时间设置为0。这将导致客户端在关闭连接时⽴即发送RST（复位）信号，⽽不是正常的四次挥⼿过程。这样可以避免 TIME_WAIT 状态，但可能导致数据丢失，因此需要谨慎使⽤。
- 优化应用程序逻辑：根据应用程序的需求，优化客户端和服务器之间的通信逻辑，以减少不必要的连接创建和关闭。例如，可以使用长连接（keep-alive）或WebSocket 等技术来保持连接，减少 TIME_WAIT 状态的数量。

## https是如何进行加密的？

HTTPS 的加密机制是通过 ​SSL/TLS 协议实现的，结合了对称加密、非对称加密、数字证书和密钥交换技术，确保数据在传输过程中的机密性、完整性和身份真实性。
流程：
TCP 连接建立->TLS 握手协商(​Client Hello,Server Hello,​证书验证,密钥交换,生成会话密钥)->加密数据传输

## 讲⼀下红⿊树的特性以及它和⼆插搜索树的区别?

- ⼆叉搜索树是⼀种特殊的⼆叉树，其中每个节点都有⼀个与之关联的键，且对于树中的所有节点，左⼦树中的所有键都小于节点的键，右⼦树中的所有键都⼤于节点的键。这使得⼆叉搜索树可以⾼效地执⾏查找、插⼊和删除操作。
- 红⿊树是⼀种自平衡的⼆叉搜索树，它在⼆叉搜索树的基础上**增加了⼀些额外的性质**。红⿊树的每个节点都有⼀个颜色属性，可以是红⾊或⿊⾊。并且节点的颜⾊之间存在⼀些特定规则。

## 为什么用epoll来实现IO复用？

- 高性能： epoll 在处理大量连接时具有较高的性能，能够有效地处理大规模的并发连接，因为它采用了事件驱动的方式，只在有事件发生时才唤醒相应的线程或进程，减少了系统调用的开销。
- 支持更多的并发连接： epoll 支持水平触发（LT）和边缘触发（ET）两种工作模式，可以更灵活地适应不同的应用场景，并且能够处理更多的并发连接。
- 支持跨平台： epoll 是 Linux 独有的系统调用，但是它的设计思想被其他操作系统所借鉴和实现，比如 FreeBSD 的 kqueue，因此可以在不同的操作系统上实现类似的功能。
- 更好的扩展性： epoll 提供了更加灵活的 API 接口，可以实现更复杂的事件处理逻辑，支持同时监控多种类型的文件描述符，包括套接字、管道、文件等。- 更好的内核支持： 随着 Linux 内核的不断升级，epoll 的性能和稳定性也在不断改善，因此成为了很多服务器开发人员的首选。

## http的keep-alive是如何实现吗？

HTTP 的 Keep-Alive 是通过在 HTTP 请求头中增加一个参数来实现的，这个参数是Connection: keep-alive。当客户端和服务器之间的通信使用了Keep-Alive 参数时，它指示服务器在发送完响应后保持 TCP 连接打开状态，以便后续的请求可以继续复用这个连接，而不必每次都重新建立连接。

## 大端序和小端序是什么？

大端序和小端序是计算机中数据在内存中存储的两种**字节顺序**。其核心区别在于高位字节与低位字节在内存地址中的**存放顺序**。

- 大端序：数据的高位字节（最左侧字节）存储在低地址，低位字节（最右侧字节）存储在高地址。网络传输就是采用的大端序。
- 小端序：数据的低位字节存储在低地址，高位字节存储在高地址。

## 同一子网内的两台设备的通信过程是怎样的？

以主机A需要给主机B发送消息为例。

- **ARP缓存检查**：主机A查看自己的ARP缓存，检查是否有主机B的IP到MAC的映射。
- **ARP请求**：如果A没有B的MAC地址，就会在广播发送一个ARP请求，B接收到了以后会响应这个请求，A收到后就会更新B的MAC地址。
- **构造报文**：如果有映射，主机A构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为主机B的MAC，源MAC为主机A的MAC。
- **MAC地址学习**：主机A将报文发送给交换机，交换机进行MAC地址表学习，将主机A的MAC和报文入端口号记录下来。
- **MAC转发表检查**：交换机C查看自己的MAC转发表，检查是否有主机B的MAC地址对应的端口号。如果有将报文从此端口转发出去，报文到达主机B。
- **ARP请求**：如果交换机C没有主机B的MAC转发表映射，采用洪泛的形式广播报文，主机B收到报文后向主机A回复，交换机C进行MAC表学习，将主机B的MAC对应的端口号记录下来。

## 不同网内的两台设备的通信过程是怎样的？

- **ARP缓存检查**：主机A查看自己的ARP缓存，检查是否有路由器的IP到MAC的映射。
- **ARP请求**：如果主机A没有路由器的MAC地址，就会发送一个ARP请求广播，路由器接收到后会响应这个请求，主机A收到后更新路由器的MAC地址。
- **构造报文**：主机A构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为路由器的MAC，源MAC为主机A的MAC。
- **MAC地址学习**：主机A将报文发送给交换机，交换机进行MAC地址表学习，将主机A的MAC和报文入端口号记录下来。
- **MAC转发表检查**：交换机查看自己的MAC转发表，检查是否有路由器的MAC到端口的映射。如果有映射，获取对应的端口，将报文从此端口转发出去，报文到达路由器。
- **路由器处理**：路由器收到报文后，剥离报文的MAC帧头，查询路由表，发现目标主机B所在的网络是直连的，查看自己的ARP缓存表，如果有主机B的IP到MAC的映射关系，获取主机B的MAC，封装报文MAC帧头，目的MAC为主机B的MAC，源MAC为路由器的MAC，将报文通过交换机发往主机B。
- **ARP请求**：如果路由器没有主机B的MAC地址映射，路由器会发送ARP请求广播，主机B接收到后会响应这个请求，路由器收到后更新主机B的MAC地址。
- **报文转发**：路由器将报文发送给交换机，交换机进行MAC地址表学习，将主机B的MAC和报文端口号记录下来，交换机查看自己的MAC转发表，检查是否有主机B的MAC到端口的映射。如果有映射，获取对应的端口，将报文从此端口转发出去，报文到达主机B。
